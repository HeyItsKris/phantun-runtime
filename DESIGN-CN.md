# phantun-runtime 设计文档（中文）

## 1. 项目背景

phantun 是一个专注于在复杂网络环境下进行高可靠数据传输的隧道程序，其设计目标本身就非常底层、克制且高性能。

然而，在实际部署和容器化使用过程中，常见的做法往往模糊了应用程序与系统平台之间的职责边界，尤其是在 Docker 或嵌入式系统（如 OpenWrt）环境中，应用程序经常在运行时隐式修改系统级网络状态。

**phantun-runtime** 项目的存在目的，正是为了明确并强制执行这一边界。

phantun-runtime 不是 phantun 的 fork，不是功能扩展，也不是管理或编排系统，而是一个严格最小化的运行时容器，其唯一职责是：在一个清晰、安全、可审计的边界内运行官方 phantun 二进制程序。

---

## 2. 设计目标

本项目的核心设计目标包括：

- 遵循最小职责原则（Least Responsibility）
- 遵循最小权限原则（Least Privilege）
- 保持与上游 phantun 的完全兼容
- 确保长期运行与运维稳定性
- 避免任何隐式或不可审计的系统行为

容器应当是一个透明的执行载体，而不是一个“替用户做决定的平台”。

---

## 3. 职责边界定义

### 3.1 本项目负责的内容

phantun-runtime 仅负责以下事项：

- 通过单一环境变量明确选择运行模式（client 或 server）
- 执行对应的官方 phantun 二进制文件
- 将所有运行参数原样透传给 phantun
- 作为 PID 1 正确接收并转发系统信号
- 在最小权限条件下使用 TUN 虚拟网卡

---

### 3.2 本项目明确不负责的内容

phantun-runtime 明确 **不做** 以下任何事情：

- 修改 sysctl 参数（例如开启 IP 转发）
- 添加、删除或修改路由规则
- 操作 iptables 或 nftables
- 执行任何形式的 NAT（SNAT / DNAT）
- 管理防火墙策略
- 自动分配或生成 IP 地址
- 解析、校验或重写 phantun 的参数
- 使用 privileged 容器模式运行

所有系统层面的网络策略，均应由宿主系统或平台管理员提前、显式地配置完成。

---

## 4. 仅运行时（Runtime-Only）理念

本项目刻意将“构建责任”与“运行责任”分离。

- phantun 官方仓库是以下内容的唯一权威来源：
  - 源代码
  - 构建逻辑
  - 二进制行为

- phantun-runtime 仅消费官方构建产物
- 不引入任何补丁、fork 或行为修改

这种分离带来的好处包括：

- 避免上游行为漂移
- 简化版本升级流程
- 提供清晰可审计的责任归属

### 4.1 构建输入与可选校验

构建过程仅消费上游源码，不做任何修改：

- 默认行为是对上游默认分支执行 `git clone`。
- 若提供 `PHANTUN_COMMIT`，则检出该提交。
- 若提供 `PHANTUN_TARBALL_SHA256`，构建会下载对应提交（或默认分支 HEAD）的源码压缩包并校验 SHA256，然后基于校验后的源码构建。

校验为可选项：默认保持轻量、开发友好的构建流程；需要可审计、可复现构建时可显式启用校验。

---

## 5. 参数透明性原则

容器运行时只识别一个用于执行的控制参数：

- `MODE=client` 或 `MODE=server`

除上述参数外，所有命令行参数都会被完整、原样地传递给 phantun 本身。接口名文件写入（`IFACE_NAME`/`IFACE_FILE`）是独立的可选约定，不影响 phantun 参数。

这一设计确保：

- phantun 新增参数时无需修改容器
- 容器永远不会成为兼容性瓶颈
- 参数语义始终由 phantun 官方定义

---

## 6. 接口名写入机制（可选）

某些部署需要一种稳定、可审计的方式来获取 TUN 接口名，同时又不能解析 phantun 参数。为保持“不解析参数”的原则，容器提供一个简单的文件写入机制：

- 外部明确提供 `IFACE_NAME`（例如 `ptun0`）。
- 外部提供 `IFACE_FILE`（容器内路径，需由宿主机挂载文件）。
- 当两者都设置时，容器会在启动 phantun 之前把 `IFACE_NAME` 写入 `IFACE_FILE`。
- 如果曾写入该文件，容器关闭时会将其清空为空字符串。
- 容器不解析或校验 phantun 参数，也不会从参数中推断接口名。
- 如果设置了 `IFACE_FILE` 但写入失败，容器会直接退出并输出错误，避免外部读取到旧值。

该机制不引入后台进程、轮询或 netlink 监听。

## 7. 安全模型

### 7.1 容器权限模型

容器仅需要以下权限：

- 访问 `/dev/net/tun`
- Linux capability：`NET_ADMIN`

容器 **不应** 使用 `--privileged` 模式运行。

---

### 7.2 行为可预测性与可审计性

phantun-runtime 的运行行为是完全确定的：

- 不存在隐式副作用
- 不修改系统全局状态
- 不包含后台辅助脚本
- 不进行动态配置变更

所有系统级影响均由外部显式控制。

---

## 8. 运维层面的设计考量

本项目刻意优先考虑：

- 运维清晰性，而非“开箱即用”
- 显式配置，而非自动化推断
- 可预测行为，而非高层抽象

这种设计非常适合 OpenWrt、Kubernetes 以及安全加固的 Linux 环境。

---

## 9. 非目标（Non-Goals）

本项目明确不追求：

- 为初学者简化 phantun 使用
- 替代编排系统或平台
- 成为 VPN 管理工具
- 提供 Web UI 或管理 API

这些需求应由更高层系统解决。

---

## 10. 总结

phantun-runtime 将 phantun 视为一个纯粹的隧道原语，将操作系统视为网络策略的唯一权威。

这种严格的关注点分离，是实现安全、可审计、可长期维护部署的基础。
